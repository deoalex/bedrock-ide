package Bedrock::IDE::API;

use strict;
use warnings;

use parent qw/Class::Accessor::Fast/;

use Bedrock::IDE::Config qw/$CONFIG $DOCUMENT_ROOT $PLUGIN_PATH $CONFIG_PATH_ROOT $INDEX_PAGE $IDE_CONFIG $PORT $PERL5LIB/;
use Bedrock::IDE::Docs;

use Data::Dumper;
use Log::Log4perl;
use Scalar::Util qw/reftype/;

Bedrock::IDE::API->mk_accessors(qw/cgi path api_path/);

my %DISPATCH = (
		'GET'   . ' ' . '/list'   => \&list,

		# /plugin
		'GET'   . ' ' . '/plugin' => \&get_plugin,
		'POST'  . ' ' . '/plugin' => \&post_plugin,
		'PUT'   . ' ' . '/plugin' => \&put_plugin,
		'DELETE'. ' ' . '/plugin' => \&delete_plugin,

		# /file
		'GET'   . ' ' . '/file'   => \&get_file,
		'POST'  . ' ' . '/file'   => \&post_file,
		'PUT'   . ' ' . '/file'   => \&post_file,
		'DELETE'. ' ' . '/file'   => \&delete_file,

		# /config
		'GET'   . ' ' . '/config' => \&get_config,
		'PUT'   . ' ' . '/config' => \&post_config,
		'POST'  . ' ' . '/config' => \&post_config,
		
		# /plugin-config		
		'GET'   . ' ' . '/plugin-config' => \&get_plugin_config,
		'POST'  . ' ' . '/plugin-config' => \&post_plugin_config,
		'PUT'   . ' ' . '/plugin-config' => \&post_plugin_config,
		'DELETE'. ' ' . '/plugin-config' => \&delete_plugin_config,
		
		# /tag
		'GET'   . ' ' . '/tag'        => \&get_tag,

		# /plugin-doc
		'GET'   . ' ' . '/plugin-doc' => \&get_plugin_doc,
	       );


sub route {
  my $self = shift;

  unless ( $self->{_route} ) {
    $self->{_route} = $self->_route;
  }

  $self->{_route};
}

sub _route {
  my $self = shift;
   
  $self->path($self->cgi->path_info());

  my $logger = Log::Log4perl::get_logger();
  $logger->debug(sprintf("Handling %s request for %s", $self->cgi->request_method(), $self->path));

  $self->api_path($1) if $self->path =~/^(\/[^\/]*)\/?/;
  
  my $route = $self->cgi->request_method() . ' ' . $self->api_path;

  $logger->debug(sprintf("API: %s", $self->api_path));
  $logger->debug(sprintf("Route: %s", $route));
  
  return $route;
}

sub dispatch {
  my $self = shift;
  
  my $code = $DISPATCH{$self->route};
  
  $code->($self) if defined $code && reftype($code) eq 'CODE';
}


# +---------+
# | HELPERS |
# +---------+

sub _get_listing {
  my $path = shift;
  my $ext = shift || '';
  
  my $logger = Log::Log4perl::get_logger();
  $logger->debug(sprintf("path: %s ext: %s", $path, $ext));
  
  my @file_list;

  if ( -d $path ) {
    opendir(my $dh, $path) || die "Can't opendir $path: $!";
    while ( my $file = readdir $dh ) {
      $logger->debug("$file");
      
      next if $file =~/^\.\.?$/ || ($ext && $file !~/\.$ext$/); 
    
      if ( -f $path . '/' . $file ) {
	push @file_list, $file;
      }
      elsif (-d $path . '/' . $file ) {
	push @file_list, { $file => [] };
      }
    }
    closedir $dh;  
  }
  
  return \@file_list;
}

sub _get_plugin_config_path {
  my $path = shift;

  my $logger = Log::Log4perl::get_logger();
  
  $path =~s/^\/plugin\-config\///;

  my $config_path = $CONFIG->{CONFIG_PATH_ROOT} || '@libdir@/bedrock';
  $config_path = $config_path . '/config.d';
  
  $logger->debug("path: $path config_path: $config_path");
  $path = lc($path);
  
  if ( -e "$config_path/startup/$path.xml") {
    $config_path = "$config_path/startup/$path.xml";
  }
  elsif ( -e "$config_path/plugin/$path.xml") {
    $config_path = "$config_path/plugin/$path.xml";
  }
  else {
    undef $config_path;
  }
  
  $config_path;
}

# - devolve a Bedrock object into Perl objects
sub _devolve {
  my $this = shift; 
  if ( ref($this) && reftype($this) eq 'HASH' ) {
    my $that = {};
    foreach ( keys %$this ) {
      $that->{$_} = _devolve( $this->{$_} );
    }
    return $that;
  }
  elsif ( ref($this) && reftype($this) eq 'ARRAY' ) {
    my $that = [];
    foreach (@$this) {
      push @$that, _devolve($_);
    }
    return $that;
  }
  elsif (! ref($this)) {
    return $this;
  }
  else {
    return undef;
  }
}

sub _set_result {
  my ($result, $message) = @_;
    
  my $data = {
	      status  => defined $result ? 'success' : 'error',
	      message => $message,
	      data    => $result
	     };
  
  return { data => $data };
}

# +----------+
# | Handlers |
# +----------+

# GET /config
sub get_config {
  my $self = shift;
  
  my $cgi = shift;
  my $path = shift;

  my $logger = Log::Log4perl::get_logger();
  
  $logger->debug("$path");
  
  return _set_result(_devolve($CONFIG));
}

# POST/config
sub post_config {
  my $self = shift;
  
  my $cgi = $self->cgi;
  my $path = $self->path;

  $path =~s/^\/config//;
  
  my $logger = Log::Log4perl::get_logger();
  $logger->debug("$path");

  my $config = $cgi->param('PUTDATA') || $cgi->param('POSTDATA');
  
  eval {
    
    if ( $config && $cgi->content_type() =~/application\/json/ ) {
      $logger->debug($config);
      $config = from_json($config);
      $logger->debug(Dumper([$config]));
    }
    else {
      die "no content or invalid content type: must be application/json\n";
    }
  
    foreach (qw/DOCUMENT_ROOT CONFIG_PATH_ROOT PLUGIN_PATH PERL5LIB PORT/) {
      unless ( exists $config->{$_} ) {
	$logger->error("missing config variable $_");
	die "missing config variable $_";
      }
    
      if ( $_ !~/(PORT|PERL5LIB)/ ) {
	unless ( -d $config->{$_} ) {
	  die "$_: " . $config->{$_} . " does not exist";
	}
      }
      elsif ($_ eq 'PORT') {
	die "invalid port" unless $PORT =~/^\d{4,5}$/;
      }
      elsif ($_ eq 'PERL5LIB') {
	foreach (split ':', $config->{$_}) {
	  unless ( -d $_ ) {
	    die "PERL5LIB: " . $_ . " does not exist";
	  }
	}
      }
      else {
	die "invalid configuration variable $_";
      }
    }
    
    if ( -d $config->{DOCUMENT_ROOT} eq '/' ) {
      die "DOCUMENT_ROOT cannot be /";
    }
  
    $CONFIG = $config;
  
    $IDE_CONFIG->{'bedrock-ide'} = $config;
  
    move('@libdir@/bedrock-ide/config/bedrock-ide.xml', '@libdir@/bedrock-ide/config/bedrock-ide.xml~');

    Bedrock::XML::writeXML($IDE_CONFIG, '@libdir@/bedrock-ide/config/bedrock-ide.xml');
  };
  
  return _set_result($@ ? undef : $config, $@);
}

# DELETE /plugin/config
sub delete_plugin_config {
  my $self = shift;
  
  my $cgi = $self->cgi;
  my $path = $self->path;
  
  my $config_path = _get_plugin_config_path($path);

  die "no plugin [$path]\n"
    unless $config_path;

  unlink($config_path);
  
  return _set_result({});
}

# GET /plugin/config
sub get_plugin_config {
  my $self = shift;
  
  my $cgi = $self->cgi;
  my $path = $self->path;
  
  my $config_path = _get_plugin_config_path($path);

  die "no plugin [$path]\n"
    unless $config_path;
  
  my $config = Bedrock::XML->new($config_path);
  
  return _set_result(_devolve($config));
}

# POST /plugin/config
sub post_plugin_config {
  my $self = shift;
  
  my $cgi = $self->cgi;
  my $path = $self->path;

  my $logger = Log::Log4perl::get_logger();
  
  my $config = $cgi->param('PUTDATA') || $cgi->param('POSTDATA');
  my $config_path = _get_plugin_config_path($path);
  
  $logger->debug(sprintf("path: %s config: %s", $config_path, $config));
  
  die "no plugin [$path]\n"
    unless $config_path;
  
  $config = from_json($config);
  $logger->debug(Dumper([$config]));
  
  if ( ref($config) && reftype($config) eq 'HASH' ) {
    Bedrock::XML::writeXML($config, $config_path);
  }
  
  return _set_result($config);
}

# GET /plugin
sub get_plugin {
  my $self = shift;
  
  my $cgi = $self->cgi;
  my $path = $self->path;

  my $logger = Log::Log4perl::get_logger();
  
  $path =~s/^\/plugin//;
  my $data;

  my $plugin_path = $CONFIG->{PLUGIN_PATH} || '@libdir@/bedrock/perl5';

  eval {
    my $plugin_list;
    
    if ( ! $path || $path eq '/' ) {
      $plugin_list = _get_listing($plugin_path . "/BLM/Startup", 'pm');
      # remove suffix
      $plugin_list = [ map { s/\.pm$//; $_; } @{$plugin_list} ];
      $data = $plugin_list;
    }
    else {
      $path = $plugin_path .  '/BLM/Startup/' . $path . '.pm';
      
      open (my $fh, "<$path") or die "could not open $path";
      local $/;
      $data = <$fh>;
      close $fh;
      $logger->debug($data);
    }
  };
  
  return _set_result($@ ? undef : $data, $@);
}

# PUT /plugin
sub put_plugin {
  my $self = shift;
  
  my $cgi = $self->cgi;
  my $path = $self->path;

  my $logger = Log::Log4perl::get_logger();
  
  $path =~s/^\/plugin//;
  
  my $plugin_path = $CONFIG->{PLUGIN_PATH} || '@libdir@/bedrock/perl5';
  $path = $plugin_path .  '/BLM/Startup/' . $path . '.pm';
  
  eval {
    # save the original
    move($path, $path . "~") if -e $path;
    $logger->debug("path: $path");

    open (my $fh, ">$path") or die "could not write [$path]";
    $fh->print($cgi->param('PUTDATA'));
    $fh->close;
  
    $logger->debug("path: $path");
  
    if ( -e $path ) {
      my $perl5lib = '';
    
      if ( $CONFIG->{PERL5LIB} ) {
	$perl5lib = '-I ' . join(' -I ', split ':', $CONFIG->{PERL5LIB});
      }
      else {
	$perl5lib = '-I @bedrockdir@/lib/bedrock/perl5';
      }
    
      $logger->debug("perl5lib: $perl5lib");
    
      my $err_code;
      my ($in, $out, $err);
    
      eval {
	my $cmd = '@perlrun@' . " -wc $perl5lib $path";
      
	$logger->debug($cmd);
      
	untie *STDERR;
	$SIG{CHLD} = 'DEFAULT';
	run3($cmd, \$in, \$out, \$err);
	$err_code = $?;
	tie *STDERR, 'Bedrock::IDE::Trapper';
      
	if ( $err_code ) {
	  $logger->debug("err_code: $err_code [$!] [$err] [$out]");
	}
	else {
	  $logger->debug("stdout: [$out] stderr: [$err]");
	}
      
	$SIG{CHLD} = 'IGNORE';
      };
    
      if ( $err_code || $@ ) {
	# restore last known good file...
	move($path . "~", $path) if -e $path . '~';
	die $@ || $err;
      }
    }
  };
  
  return _set_result($@ ? undef : $path, $@);
}

# POST /plugin
sub post_plugin {
  my $self = shift;
  
  my $cgi = $self->cgi;
  my $path = $self->path;

  my $logger = Log::Log4perl::get_logger();
  
  $path =~s/^\/plugin//;
  my $config_path = $CONFIG->{CONFIG_PATH_ROOT} || '@libdir@/bedrock';
  my $plugin_path = $CONFIG->{PLUGIN_PATH} || '@libdir@/bedrock/perl5';
  
  my $result = {
		status => 'HTTP/1.0 200 OK',
		content_type => 'text/plain'
	       };
  
  my $plugin = $cgi->param('plugin');
  my $binding = $cgi->param('binding') || lc($plugin);
  
  if ( $plugin && $binding ) {
    $logger->debug(sprintf("plugin: %s binding: %s", $plugin, $binding));
    `@bindir@/bedrock-plugin -x -r -d $plugin_path -c $config_path -m $plugin -b $binding`;
    $plugin = "$plugin_path/BLM/Startup/${plugin}.pm";
    open (my $fh, "<$plugin") or die "could not create plugin [$plugin]";
    local $/;
    $result->{data} = <$fh>;
    close $fh;
  }
  else {
    die "module and binding must be provided\n";
  }

  return _set_result($@ ? undef : $path, $@);
}

# DELETE /plugin
sub delete_plugin {
  my $self = shift;
  
  my $cgi = $self->cgi;
  my $path = $self->path;

  my $logger = Log::Log4perl::get_logger();
  
  my $config_path = _get_plugin_config_path($path);

  $path =~s/^\/plugin//;

  my $plugin_path = $CONFIG->{PLUGIN_PATH} || '@libdir@/bedrock/perl5';
  $path = $plugin_path .  '/BLM/Startup/' . $path . '.pm';

  unlink $path if -e $path;
  unlink $config_path if -e $config_path;

  return _set_result($@ ? undef : $path, $@);
}

# GET /file
sub get_file {
  my $self = shift;
  
  my $cgi = $self->cgi;
  my $path = $self->path;

  my $logger = Log::Log4perl::get_logger();
  
  my $DOCUMENT_ROOT = $CONFIG->{DOCUMENT_ROOT};
  
  $path =~s/^\/file//;
  $path = $DOCUMENT_ROOT . $path;

  $logger->debug("$path");
  
  my $text;

  eval {
    open (my $fh, "<$path") or die "could not open file [$path]";
    local $/;
    $text = <$fh>;
    close $fh;
  };
    
  return _set_result($@ ? undef : $text, $@);
}

# POST /file
sub post_file {
  my $self = shift;
  
  my $cgi = $self->cgi;
  my $path = $self->path;

  my $logger = Log::Log4perl::get_logger();
  my $text = $cgi->param('POSTDATA') || $cgi->param('PUTDATA');
  
  my $DOCUMENT_ROOT = $CONFIG->{DOCUMENT_ROOT};
  
  $path =~s/^\/file//;
  $path = $DOCUMENT_ROOT . $path;

  $logger->debug("path: [$path]");
  $logger->debug("text: [$text]");
  
  eval {
    open (my $fh, ">$path") or die "could not open file [$path]";
    $fh->print($text);
    close $fh;
  };
    
  return _set_result($@ ? undef : $text, $@);
}

# DELETE /file
sub delete_file {
  my $self = shift;
  
  my $cgi = $self->cgi;
  my $path = $self->path;

  my $logger = Log::Log4perl::get_logger();
  
  my $DOCUMENT_ROOT = $CONFIG->{DOCUMENT_ROOT};
  
  $path =~s/^\/file//;
  $path = $DOCUMENT_ROOT . $path;

  $logger->debug("$path");

  if ( -e $path ) {
    unlink $path;
  }
  
  return _set_result($@ ? undef : $path, $@);
}

# GET /list
sub list {
  my $self = shift;
  
  my $cgi = $self->cgi;
  my $path = $self->path;

  my $logger = Log::Log4perl::get_logger();
  
  my $DOCUMENT_ROOT = $CONFIG->{DOCUMENT_ROOT};
  
  $path =~s/^\/list//;
  $path = $DOCUMENT_ROOT . $path;
  
  $logger->debug("DOCUMENT_ROOT: $DOCUMENT_ROOT path: $path");

  my $listing = eval {
    _get_listing($path, $cgi->param('ext'));
  };
  
  $logger->debug(Dumper($listing));
  
  return _set_result($@ ? undef : $listing, $@);
}

sub get_tag {
  my $self = shift;
  my $path = $self->path;
  my $logger = Log::Log4perl::get_logger();
  
  $logger->debug("path: $path");

  my $tag = lc($1) if $path =~/^\/tag\/([^\/]*$)/;
  my $docs = Bedrock::IDE::Docs->new({css_url => '/bedrock-ide/css'});

  my $result;
    
  if ( $tag ) {
    my $tag_file = $docs->find_tag_file($tag);
    $result = $docs->pod($tag_file) if $tag_file;

    $logger->debug($result);
  }
  else {
    $result = $docs->tags;
  }
  
  return _set_result($@ ? undef : $result, $@);
}

sub get_plugin_doc {
  my $self = shift;
  my $path = $self->path;

  my $logger = Log::Log4perl::get_logger;
  my $plugin = $1 if $path =~/^\/plugin-doc\/(.*)$/;
  
  my $docs = Bedrock::IDE::Docs->new({css_url => '/bedrock-ide/css', plugin_path => $PLUGIN_PATH});
  
  my $result = eval {
    $docs->get_plugin_listing();
  };
  
  if ( $result ) {
    if ( $plugin ) {
      $result =  $result->{$plugin} ? $docs->pod($result->{$plugin} . '.pm') : undef;
    }
    else {
      my @startup_blms = grep { /^Startup:/ } sort keys %$result;
      my @blms = grep { ! /^Startup:/ } sort keys %$result;
      $result = { 'application-plugins' => \@startup_blms,
		  'plugins' => \@blms
		};
    }
  }
  
  $logger->debug($result);
  
  return _set_result($@ ? undef : $result, $@);
}

1;
